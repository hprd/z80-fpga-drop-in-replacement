`timescale 1ns / 1ps
`include "z80_defines.v"
`include "pla_defines.v"

module execute
(
    //----------------------------------------------------------
    // Control signals generated by the instruction execution
    //----------------------------------------------------------


    output reg nextM,                   // Last M cycle of any instruction
    output reg setM1,                   // Last T clock of any instruction
    output reg [15:0] ADDRESS_BUS,         // Memory address for Mem Reads/Writes
    output reg MREQ_b,                  
    output reg RD_b,
    output reg WR_b,
    output reg M1_b,
    output reg RFSH_b,
    output reg [7:0] DATA_OUT,
    output use_ixiy,
    output in_halt,
    output table_cb,
    output table_ed,
    output in_alu,
    output reg [7:0] opcode,
    output HALT_b,
    
    //----------------------------------------------------------
    // Inputs from the instruction decode PLA
    //----------------------------------------------------------
    input wire [104:0] pla,             // Statically decoded instructions


    // Machine and clock cycles
    //----------------------------------------------------------
    input wire M1,                      // Machine cycle #1
    input wire M2,                      // Machine cycle #2
    input wire M3,                      // Machine cycle #3
    input wire M4,                      // Machine cycle #4
    input wire M5,                      // Machine cycle #5
    input wire T1,                      // T-cycle #1
    input wire T2,                      // T-cycle #2
    input wire T3,                      // T-cycle #3
    input wire T4,                      // T-cycle #4
    input wire T5,                      // T-cycle #5
    input wire T6,                       // T-cycle #6
    input [7:0] DATA_IN,
    input RESET_b,
    input NMI_b,

    
    input CLK_b
    );

reg counter = 1'b0;
always @(posedge CLK_b) begin
    counter <= ~counter;
end

`define POS_EDGE counter == 1'b1
`define NEG_EDGE counter == 1'b0

reg [15:0] PC = 0;
reg use_ixiy = 0;
reg in_halt = 0;
reg table_cb = 0;
reg table_ed = 0;
reg in_alu = 0;
reg HALT_b = 1;

//--------------------------------------------------------------
// Make available different bits and sections of the opcode byte
//--------------------------------------------------------------
wire op0 = pla[99];
wire op1 = pla[100];
wire op2 = pla[101];
wire op3 = pla[102];
wire op4 = pla[103];
wire op5 = pla[104];

wire [1:0] op21 = { pla[101], pla[100] };
wire [1:0] op54 = { pla[104], pla[103] };

//--------------------------------------------------------------
// 8-bit register selections needs to swizzle mux for A and F
//--------------------------------------------------------------
wire rsel0 = op0 ^ (op1 & op2);
wire rsel3 = op3 ^ (op4 & op5);

/////////////////////
//Register File Initialization
/////////////////////
    reg [3:0] SR1, SR2, DR;
    reg [15:0] REG_IN;
    reg LD_REG;
    reg EXTOGGLE_DEHL;
    reg EXXTOGGLE;
    wire [15:0] SR1_OUT, SR2_OUT;
    reg [7:0] accum;
    reg [7:0] operand;
    
reg_file reg_file_(
    .clk(counter),
    .rst(RESET_b),
    .SR1(SR1),
    .SR2(SR2),
    .DR(DR),
    .REG_IN(REG_IN),
    .LD_REG(LD_REG),
    .EXTOGGLE_DEHL(EXTOGGLE_DEHL),
    .EXXTOGGLE(EXXTOGGLE),
    .SR1_OUT(SR1_OUT),
    .SR2_OUT(SR2_OUT)
 );

/////////////////////
//ALU Initialization
/////////////////////
    reg [6:0] ALU_OP;
    reg [15:0] operandA;
    reg [15:0] operandB;
    reg [7:0] flag = 0;
    wire [15:0] ALU_OUT;
    wire [7:0] FLAG_OUT;
    reg [2:0] condition_in;
    wire check_out;
    reg [15:0] next_PC;


ALU_Core ALU_(
    .ALU_OP(ALU_OP),
    .operandA(operandA),
    .operandB(operandB),
    .flag(flag),
    .ALU_OUT(ALU_OUT),
    .FLAG_OUT(FLAG_OUT)
);

condition_check condition_check_(
    .flag(flag),
    .condition_in(condition_in),
    .check_out(check_out)
);

localparam REG_HL = 4'd10;  //Register File HL parameter
reg [15:0] hl_latched;
reg [7:0]  r_latched;

    reg halt_flag = 0;
    
    always @(posedge CLK_b) begin
        if(!RESET_b) begin
            PC <= 0;
        end
        if(`POS_EDGE) begin
//    /////////////////////
//    //OPCODE FETCH
//    /////////////////////            
            if(M1 & T1) begin
                ADDRESS_BUS <= PC;
                RFSH_b <= 1;
                WR_b <= 1;
            end
            else if(M1 & T2) begin
                opcode <= DATA_IN;
                MREQ_b <= 1;
                RD_b <= 1;
                M1_b <= 1;
            end
            else if(M1 & T4) begin
                ADDRESS_BUS <= PC;
            end
//    /////////////////////
//    //LD r , n (8-bit Immediate Register Load)
//    /////////////////////
            if(`LD_r_n) begin
                    if(M1 & T3) begin
                        PC <= PC + 1;
                    end
                    else if (M2 & T2) begin  
                        DR <= {1'b0, opcode[5:3]};
                        LD_REG <= 1;
                        PC <= PC + 1;
                    end            
                    else if(M2 & T3) begin
                        LD_REG <= 0;
                        ADDRESS_BUS <= PC;
                    end        
            end
//    /////////////////////
//    //LD hl , r (8-bit Load into Memory from Register)
//    //M1: T1-T4 opcode fetch
//    //M2: T1-T3 Actual memory write  
//    /////////////////////
            if(`LD_hl_r)begin
                if(M1 & T3)begin
                    PC <= PC + 1;
                end
                else if(M1 & T4)begin
                    hl_latched <= SR2_OUT;          //HL register
                    r_latched <= SR1_OUT[7:0];      //Source register
                    PC <= PC + 1;
                    ADDRESS_BUS <= SR2_OUT;      //Address on the bus
                    //DATA_OUT <= SR1_OUT[7:0];          //register as data to write
                end
               // else if(M2 & T1)begin
                    //ADDRESS_BUS <= hl_latched;      //Address on the bus
                    //DATA_OUT <= r_latched;          //register as data to write
                //end
                else if(M2 & T3)begin
                    ADDRESS_BUS <= PC;
                end 
            end   
//    /////////////////////
//    //ALU a, r (8-bit ALU Operation from Register on Accumulator)
//    /////////////////////
            if(`ALU_A_r) begin
                if (M1 & T3) begin 
                    operandA <= SR2_OUT;
                    operandB <= SR1_OUT;
                    LD_REG <= 1;
                    DR <= 14'h7;              
                    PC <= PC + 1;
                    if (`ADD_OP) begin // add a, r
                        ALU_OP <= `ALU_ADD_8BIT;
                    end     
                end            
                else if (M1 & T4) begin
                    in_alu <= 0;
                    LD_REG <= 0;
                end                         
            end
//    /////////////////////
//    //JP cc , nn  (Conditional Jump to Address NN)
//    /////////////////////         
            if(`JP_cc_nn) begin
                if(M1 & T3) begin
                    PC <= PC + 1;
                end
                else if(M2 & T3) begin
                    ADDRESS_BUS <= PC;
                end 
                else if (M3 & T2) begin  
                    if(~check_out) begin
                        PC <= PC + 1;
                    end
                end            
                else if(M3 & T3) begin
                    ADDRESS_BUS <= PC;
                end                
            end
//    /////////////////////
//    //HALT
//    /////////////////////            
            if(`HALT) begin
                if(M1 & T3) begin
                    if(~NMI_b) begin
                        PC <= PC + 1;
                        halt_flag <= 1;
                    end
                end
                else if(M1 & T4) begin
                    HALT_b <= 0;
                end                
            end
                           
        end
  
        else if(`NEG_EDGE) begin
//    /////////////////////
//    //OPCODE FETCH
//    /////////////////////  
            nextM = 0;                          
            setM1 = 0;  
            if(M1 & T1) begin
                MREQ_b <= 0;
                RD_b <= 0;
            end
            else if(M1 & T4) begin
                nextM <= 1;
            end
//    /////////////////////
//    //LD r , n (8-bit Immediate Register Load)
//    /////////////////////
            if (`LD_r_n) begin
                if(M2 & T1) begin
                    MREQ_b <= 0;
                    RD_b <= 0;
                end
                else if(M2 & T2) begin
                    REG_IN <= DATA_IN;
                end
                else if(M2 & T3) begin
                    MREQ_b <= 1;
                    RD_b <= 1;
                    setM1 <= 1;
                    M1_b <= 0;       
                end        
            end
//    /////////////////////
//    //LD hl , r (8-bit Load into Memory from Register)
//    //M1: T1-T4 opcode fetch
//    //M2: T1-T3 Actual memory write  
//    /////////////////////
            else if(`LD_hl_r)begin
                if(M1 & T3)begin                    //Set reg file select lines so outputs settle before M1 T4
                    SR1 <= {1'b0, opcode[2:0]};
                    SR2 <= REG_HL;
                end
                else if(M2 & T1)begin
                    MREQ_b <= 0;
                    DATA_OUT <= SR1_OUT[7:0];
                end
                else if(M2 & T2)begin
                    WR_b <= 0;
                end
                else if(M2 & T3)begin               //deassert WR (WR goes high on rising edge of T3)
                    WR_b <= 1;
                    MREQ_b <=1;
                    M1_b <=0;
                    
                    setM1 <=1;
                end
            end   
//    /////////////////////
//    //ALU a, r (8-bit ALU Operation from Register on Accumulator)
//    /////////////////////    
            if (`ALU_A_r) begin
                if (M1 & T3) begin
                    in_alu <= 1;
                    SR1 <= opcode[2:0];
                    SR2 <= 4'h7;                
                end           
                else if (M1 & T4) begin
                    if (`ADD_OP) begin // add a, r
                        REG_IN <= ALU_OUT;
                        flag <= FLAG_OUT;
                    end    
                    else begin REG_IN = accum; end
                    setM1 <= 1;
                    M1_b <= 0;
                end        
            end
//    /////////////////////
//    //JP cc , nn  (Conditional Jump to Address NN)
//    /////////////////////   
            if (`JP_cc_nn) begin
                if(M1 & T3) begin
                    condition_in <= opcode[5:3];
                end
                else if(M2 & T1) begin
                    MREQ_b <= 0;
                    RD_b <= 0;
                end
                else if(M2 & T2) begin
                    if(check_out) begin
                        next_PC <= DATA_IN;
                    end
                    PC <= PC + 1;
                end
                else if(M2 & T3) begin
                    MREQ_b <= 1;
                    RD_b <= 1;
                    nextM <= 1;
                end    
                else if(M3 & T1) begin
                    MREQ_b <= 0;
                    RD_b <= 0;
                end
                else if(M3 & T3) begin
                    if(check_out) begin
                        PC <= next_PC + (DATA_IN << 8);
                    end
                    MREQ_b <= 1;
                    RD_b <= 1;
                    setM1 <= 1;
                    M1_b <= 0;
                end               
            end
//    /////////////////////
//    //HALT
//    /////////////////////
            if (`HALT) begin
                if(M1 & T3) begin
                    if(~NMI_b) begin
                        HALT_b <= 0;
                    end
                end 
                if(M1 & T4) begin
                    setM1 <= 1;
                    if(halt_flag) begin
                        halt_flag <= 1;
                        HALT_b <= 1;
                    end
                end         
            end                
        end
        else begin end
    end

endmodule


module condition_check(
    input [7:0] flag,
    input [2:0] condition_in,
    output reg check_out
);
    
    always  @(*) begin
        case(condition_in)
            3'b000: check_out <= ~flag[`FLAG_Z];   // NZ condition (NON-ZERO)
            3'b001: check_out <= flag[`FLAG_Z];    // Z condition  (ZERO)
            3'b010: check_out <= ~flag[`FLAG_C];   // NC condition (NO CARRY)
            3'b011: check_out <= flag[`FLAG_C];   // C condition   (CARRY)
            3'b100: check_out <= ~flag[`FLAG_PV];   // PO condition (ODD)
            3'b101: check_out <= flag[`FLAG_PV];    // PE condition (EVEN)
            3'b110: check_out <= ~flag[`FLAG_S];   // P condition (POSITIVE)
            3'b111: check_out <= flag[`FLAG_S];   // NP condition (NEGATIVE)
        endcase
    end
    
endmodule
